---
phase: 03-system-tray-fixes
plan: 02
type: execute
wave: 2
depends_on: [03-01]
files_modified: [app.go]
autonomous: false

must_haves:
  truths:
    - "点击'退出应用'菜单项能够完全退出应用"
    - "点击窗口关闭按钮(X)能够隐藏到托盘而非退出"
    - "多次点击'退出应用'不会导致重复退出或 panic"
    - "日志中无竞态条件相关错误"
  artifacts:
    - path: "app.go"
      provides: "线程安全的退出逻辑,区分最小化到托盘和退出应用"
      exports: ["quitApplication", "onBeforeClose", "systrayExit", "quitting"]
      contains: "sync.Once"
      contains: "atomic.Bool"
  key_links:
    - from: "app.go:quitApplication"
      to: "app.onBeforeClose"
      via: "quitting atomic.Bool 标志"
      pattern: "quitting\\.Store\\(true\\)"
    - from: "app.go:onBeforeClose"
      to: "app.hideWindow"
      via: "非退出状态下调用 hideWindow()"
      pattern: "quitting\\.Load\\(\\)"
---

<objective>
修复托盘竞态条件并优化退出行为

Purpose: 确保托盘退出逻辑线程安全,使用 sync.Once 和 atomic.Bool 防止竞态条件,正确区分"最小化到托盘"和"退出应用"两种行为。

Output: 线程安全的退出逻辑,清晰的退出/最小化行为区分,无竞态条件的托盘交互。
</objective>

<execution_context>
@C:\Users\allan716\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\allan716\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/03-system-tray-fixes/03-RESEARCH.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Existing exit logic (already implements sync.Once and atomic.Bool)
@app.go (lines 66-73, 475-491, 599-626)
</context>

<tasks>

<task type="auto">
  <name>Task 1: 验证和加固现有的竞态条件防护</name>
  <files>app.go</files>
  <action>
    1. 验证 App 结构体中已正确声明竞态条件防护字段 (lines 66-73):
       - systrayExit *sync.Once
       - systrayRunning atomic.Bool
       - quitting atomic.Bool
       - windowMutex sync.RWMutex
       - windowVisible bool

       如果任何字段缺失,添加它们。

    2. 验证 quitApplication() 方法正确使用 sync.Once (lines 475-491):
       ```go
       func (a *App) quitApplication() {
           a.systrayExit.Do(func() {
               logger.Info("应用正在退出...")
               a.quitting.Store(true)  // 必须在所有其他操作之前
               a.showWindow()
               systray.Quit()
           })
       }
       ```

       关键要点:
       - quitting.Store(true) 必须是第一个操作
       - 使用 sync.Once 确保只执行一次

    3. 验证 onBeforeClose() 正确检查 quitting 标志 (lines 599-626):
       ```go
       func (a *App) onBeforeClose(ctx context.Context) (prevent bool) {
           // 保存窗口状态...

           if a.quitting.Load() {
               logger.Info("应用正在退出,允许窗口关闭")
               return false  // 允许关闭
           }

           logger.Info("窗口关闭事件被触发,将隐藏到托盘")
           a.hideWindow()
           return true  // 拦截关闭,隐藏到托盘
       }
       ```

       关键要点:
       - 必须先检查 a.quitting.Load()
       - 返回 false 表示允许关闭
       - 返回 true 表示拦截关闭

    4. 添加竞态条件检测日志 (可选但有助于调试):
       ```go
       func (a *App) quitApplication() {
           a.systrayExit.Do(func() {
               logger.Info("应用正在退出...")

               // 验证当前状态
               wasQuitting := a.quitting.Swap(true)
               if wasQuitting {
                   logger.Warn("退出逻辑已被调用过,这是不应该的状态")
                   return
               }

               a.showWindow()
               systray.Quit()
           })
       }
       ```

       注意: 使用 atomic.Swap 可以检测重复调用。

    5. 如果需要,添加 goroutine 泄漏检测 (在 onSystrayExit 中):
       ```go
       func (a *App) onSystrayExit() {
           logger.Info("系统托盘已退出")

           // 验证 systray 运行状态
           if a.systrayRunning.Load() {
               logger.Warn("systrayRunning 标志未正确清理")
           }
           a.systrayRunning.Store(false)

           if a.quitting.Load() {
               logger.Info("触发 Wails 应用退出...")
               if a.ctx != nil {
                   runtime.Quit(a.ctx)
               }
           }
       }
       ```
  </action>
  <verify>go build -o build/bin/ai-commit-hub.exe . 编译成功</verify>
  <done>sync.Once 和 atomic.Bool 正确使用,无竞态条件风险</done>
</task>

<task type="auto">
  <name>Task 2: 优化托盘菜单项状态和交互</name>
  <files>app.go</files>
  <action>
    1. 添加"隐藏窗口"菜单项 (当窗口可见时显示):
       在 onSystrayReady() 中:
       ```go
       // 显示/隐藏窗口菜单项
       showHideMenu := systray.AddMenuItem("隐藏窗口", "隐藏主窗口")
       showHideMenu.Click(func() {
           a.windowMutex.RLock()
           visible := a.windowVisible
           a.windowMutex.RUnlock()

           if visible {
               a.hideWindow()
               showHideMenu.SetTitle("显示窗口")
               showHideMenu.SetTooltip("显示主窗口")
           } else {
               a.showWindow()
               showHideMenu.SetTitle("隐藏窗口")
               showHideMenu.SetTooltip("隐藏主窗口")
           }
       })
       ```

       或者更简单的方案: 保持单一"显示窗口"菜单项,始终调用 showWindow()
       (因为 showWindow() 内部会检查 windowVisible 标志)

    2. 添加"检查更新"菜单项 (调用现有的更新检查):
       ```go
       checkUpdateMenu := systray.AddMenuItem("检查更新", "检查应用更新")
       checkUpdateMenu.Click(func() {
           go func() {
               updateInfo, err := a.updateService.CheckForUpdates()
               if err != nil {
                   logger.Warnf("检查更新失败: %v", err)
                   return
               }
               if updateInfo.HasUpdate {
                   logger.Info("发现新版本", "version", updateInfo.LatestVersion)
                   runtime.EventsEmit(a.ctx, "update-available", updateInfo)
               } else {
                   logger.Info("已是最新版本")
               }
           }()
       })
       ```

    3. 调整菜单项顺序 (符合用户习惯):
       - 显示/隐藏窗口 (始终第一项)
       - 分隔线
       - 检查更新
       - 分隔线
       - 退出应用

    4. 更新 Tooltip 文字 (反映双击功能):
       ```go
       systray.SetTooltip("AI Commit Hub - 双击显示/隐藏窗口")
       ```

    5. 添加窗口状态变化时更新菜单项标题的功能:
       在 showWindow() 和 hideWindow() 中添加事件发射:
       ```go
       runtime.EventsEmit(a.ctx, "window-shown", map[string]interface{}{
           "timestamp": time.Now(),
       })
       ```

       前端可以监听这些事件更新 UI,但菜单项标题更新需要在 Go 端实现。
  </action>
  <verify>go build -o build/bin/ai-commit-hub.exe . 编译成功</verify>
  <done>托盘菜单项完整,包含显示/隐藏、检查更新、退出选项</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>托盘竞态条件防护和菜单项优化</what-built>
  <how-to-verify>
    1. 构建应用:
       ```bash
       wails build
       ```

    2. 测试退出流程:
       - 启动应用
       - 点击"退出应用"菜单项
       - **验证**: 应用应该完全退出,进程终止
       - **验证**: 日志中"应用正在退出"只出现一次

    3. 测试最小化到托盘:
       - 启动应用
       - 点击窗口关闭按钮 (X)
       - **验证**: 窗口应该隐藏,但应用继续运行 (托盘图标存在)
       - **验证**: 应用进程仍在运行中

    4. 测试重复点击退出:
       - 启动应用
       - 快速多次点击"退出应用"菜单项
       - **验证**: 应用只退出一次,无 panic 错误
       - **验证**: 日志中无竞态条件警告

    5. 测试菜单项:
       - 右键点击托盘图标
       - **验证**: 菜单包含"显示窗口"、"检查更新"、"退出应用"三项
       - 点击"检查更新"
       - **验证**: 日志显示检查更新结果

    6. 压力测试:
       - 启动应用
       - 快速连续: 隐藏窗口 → 双击显示 → 隐藏窗口 → 双击显示
       - **验证**: 每次操作都能正确响应
       - **验证**: 日志中无竞态条件或 panic 错误
  </how-to-verify>
  <resume-signal>输入 "approved" 表示测试通过,或描述遇到的问题</resume-signal>
</task>

</tasks>

<verification>
- [ ] sync.Once 用于 systrayExit
- [ ] atomic.Bool 用于 quitting 和 systrayRunning
- [ ] quitting.Store(true) 在退出逻辑中首先执行
- [ ] onBeforeClose 正确检查 quitting 标志
- [ ] 菜单包含"显示/隐藏"、"检查更新"、"退出"选项
- [ ] 重复点击退出不会导致问题
- [ ] 最小化到托盘功能正常工作
</verification>

<success_criteria>
托盘交互稳定可靠,无竞态条件,退出和最小化行为区分清晰。
</success_criteria>

<output>
After completion, create `.planning/phases/03-system-tray-fixes/03-02-SUMMARY.md`
</output>
