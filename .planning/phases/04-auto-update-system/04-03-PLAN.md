---
phase: 04-auto-update-system
plan: 03
type: execute
wave: 3
depends_on: [04-01, 04-02]
files_modified: [pkg/update/updater/main.go, pkg/update/installer.go, pkg/update/updater/updater.go]
autonomous: false

must_haves:
  truths:
    - "更新器程序作为独立可执行文件构建"
    - "更新器接受命令行参数（--source, --target, --pid, --exec）"
    - "更新器等待主程序完全退出（最多 30 秒）"
    - "更新器解压 ZIP 到临时目录验证后替换文件"
    - "更新器先备份旧版本，失败时自动回滚"
    - "更新器显示独立进度窗口（中文界面）"
    - "更新完成后自动启动新版本应用"
  artifacts:
    - path: "pkg/update/updater/main.go"
      provides: "外部更新器程序入口"
      exports: ["main"]
      min_lines: 200
      contains: "flag.Parse,waitForProcessExit,unzip,backupFiles"
    - path: "pkg/update/installer.go"
      provides: "更新器释放和启动逻辑"
      exports: ["ExtractUpdater", "Install"]
      contains: "embed.FS,updater.exe,WriteFile"
    - path: "pkg/update/updater/updater.go"
      provides: "更新器核心功能（解压、替换、验证）"
      exports: ["RunUpdate", "Unzip", "BackupFiles", "ReplaceFiles", "VerifyAndLaunch"]
      min_lines: 300
  key_links:
    - from: "pkg/update/installer.go"
      to: "pkg/update/updater/main.go"
      via: "embed and extract updater binary"
      pattern: "embed.FS.*updater"
    - from: "pkg/update/updater/main.go"
      to: "os/exec.Cmd"
      via: "launch new version after update"
      pattern: "exec.Command.*Start"
    - from: "pkg/update/updater/main.go"
      to: "archive/zip"
      via: "extract ZIP package"
      pattern: "zip.OpenReader"
---

<objective>
实现外部更新器程序

Purpose: Windows 下无法直接替换正在运行的可执行文件，必须使用外部更新器程序。更新器需要：1) 等待主程序退出；2) 解压 ZIP 更新包；3) 备份旧版本；4) 替换文件；5) 启动新版本。更新器作为独立程序构建，通过 embed 嵌入主程序，运行时释放到临时目录。

Output: 独立的更新器程序（updater.exe），嵌入主程序中，支持解压、备份、替换、回滚、自动启动。
</objective>

<execution_context>
@C:\Users\allan716\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\allan716\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/04-auto-update-system/04-RESEARCH.md
@.planning/phases/04-auto-update-system/04-CONTEXT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@pkg/update/installer.go
@pkg/update/downloader.go
</context>

<tasks>

<task type="auto">
  <name>任务 1: 创建更新器目录和基础结构</name>
  <files>pkg/update/updater/main.go</files>
  <action>
    创建 `pkg/update/updater/main.go`，这是更新器的入口点：

    1. 添加必要的 import：
       ```go
       package main

       import (
           "flag"
           "fmt"
           "io"
           "os"
           "os/exec"
           "path/filepath"
           "syscall"
           "time"
           "archive/zip"
       )
       ```

    2. 定义命令行参数：
       ```go
       var (
           source   = flag.String("source", "", "更新包路径 (ZIP 文件)")
           target   = flag.String("target", "", "安装目录")
           pid      = flag.Int("pid", 0, "主进程 PID")
           execPath = flag.String("exec", "", "主程序完整路径")
       )
       ```

    3. 实现 main 函数流程：
       ```go
       func main() {
           flag.Parse()

           // 验证参数
           if *source == "" || *target == "" {
               fmt.Println("参数不完整")
               flag.Usage()
               return
           }

           // 1. 等待主程序退出
           if *pid > 0 {
               if err := waitForProcessExit(*pid); err != nil {
                   fmt.Printf("等待主程序退出失败: %v\n", err)
                   return
               }
           }

           // 2. 解压 ZIP 到临时目录
           tmpDir, err := unzipToTemp(*source)
           if err != nil {
               fmt.Printf("解压失败: %v\n", err)
               return
           }
           defer os.RemoveAll(tmpDir)

           // 3. 验证 ZIP 内容
           if err := validateZipContent(tmpDir); err != nil {
               fmt.Printf("验证失败: %v\n", err)
               return
           }

           // 4. 备份旧版本
           backupDir := filepath.Join(*target, "backup")
           if err := backupFiles(*target, backupDir); err != nil {
               fmt.Printf("备份失败: %v\n", err)
               return
           }

           // 5. 替换文件
           if err := replaceFiles(tmpDir, *target); err != nil {
               fmt.Printf("替换失败，正在回滚: %v\n", err)
               rollback(backupDir, *target)
               return
           }

           // 6. 清理旧备份（保留最近 1 次）
           cleanupOldBackups(backupDir)

           // 7. 启动新版本
           if *execPath != "" {
               time.Sleep(2 * time.Second)
               if err := launchNewVersion(*execPath); err != nil {
                   fmt.Printf("启动新版本失败: %v\n", err)
               }
           }
       }
       ```

    4. 实现辅助函数：
       - `waitForProcessExit(pid int) error`: 等待进程退出，最多 30 秒
       - `unzipToTemp(zipPath string) (string, error)`: 解压到临时目录
       - `validateZipContent(dir string) error`: 验证包含预期文件
       - `backupFiles(targetDir, backupDir string) error`: 备份旧版本
       - `replaceFiles(srcDir, targetDir string) error`: 替换文件
       - `rollback(backupDir, targetDir string) error`: 回滚
       - `cleanupOldBackups(backupDir string) error`: 清理旧备份
       - `launchNewVersion(execPath string) error`: 启动新版本

    **注意**：更新器是独立的 main 包，有自己的 main 函数。
  </action>
  <verify>
    ```bash
    cd C:/WorkSpace/Go2Hell/src/github.com/allanpk716/ai-commit-hub
    go build -o tmp/updater.exe ./pkg/update/updater
    ```
  </verify>
  <done>
    - updater/main.go 创建成功
    - 更新器可以独立编译
    - 命令行参数解析正确
    - 所有辅助函数实现完整
    - 编译成功
  </done>
</task>

<task type="auto">
  <name>任务 2: 实现更新器核心功能</name>
  <files>pkg/update/updater/updater.go</files>
  <action>
    创建 `pkg/update/updater/updater.go`，实现更新器核心功能：

    1. 实现 waitForProcessExit：
       ```go
       func waitForProcessExit(pid int) error {
           for i := 0; i < 30; i++ {
               process, err := os.FindProcess(pid)
               if err != nil {
                   return nil // 进程已不存在
               }

               // 发送信号 0 检查进程是否存在
               err = process.Signal(syscall.Signal(0))
               if err != nil {
                   return nil // 进程已退出
               }

               time.Sleep(1 * time.Second)
           }
           return fmt.Errorf("等待主程序退出超时")
       }
       ```

    2. 实现 unzipToTemp：
       ```go
       func unzipToTemp(zipPath string) (string, error) {
           tmpDir, err := os.MkdirTemp("", "update-*")
           if err != nil {
               return "", err
           }

           r, err := zip.OpenReader(zipPath)
           if err != nil {
               os.RemoveAll(tmpDir)
               return "", err
           }
           defer r.Close()

           for _, f := range r.File {
               rc, err := f.Open()
               if err != nil {
                   continue
               }

               path := filepath.Join(tmpDir, f.Name)
               if f.FileInfo().IsDir() {
                   os.MkdirAll(path, f.Mode())
                   rc.Close()
                   continue
               }

               if err := os.MkdirAll(filepath.Dir(path), 0755); err != nil {
                   rc.Close()
                   continue
               }

               out, err := os.OpenFile(path, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, f.Mode())
               if err != nil {
                   rc.Close()
                   continue
               }

               _, err = io.Copy(out, rc)
               out.Close()
               rc.Close()

               if err != nil {
                   return "", err
               }
           }

           return tmpDir, nil
       }
       ```

    3. 实现 validateZipContent：
       ```go
       func validateZipContent(dir string) error {
           // 检查是否存在主程序 exe
           exeFiles, err := filepath.Glob(filepath.Join(dir, "*.exe"))
           if err != nil || len(exeFiles) == 0 {
               return fmt.Errorf("更新包中未找到可执行文件")
           }
           return nil
       }
       ```

    4. 实现 backupFiles：
       ```go
       func backupFiles(targetDir, backupDir string) error {
           if err := os.MkdirAll(backupDir, 0755); err != nil {
               return err
           }

           // 备份 exe 文件
           exeFiles, _ := filepath.Glob(filepath.Join(targetDir, "*.exe"))
           for _, src := range exeFiles {
               dst := filepath.Join(backupDir, filepath.Base(src))
               if err := copyFile(src, dst); err != nil {
                   return err
               }
           }

           return nil
       }
       ```

    5. 实现 replaceFiles：
       ```go
       func replaceFiles(srcDir, targetDir string) error {
           return filepath.Walk(srcDir, func(path string, info os.FileInfo, err error) error {
               if err != nil {
                   return err
               }

               relPath, err := filepath.Rel(srcDir, path)
               if err != nil {
                   return err
               }

               dstPath := filepath.Join(targetDir, relPath)

               if info.IsDir() {
                   return os.MkdirAll(dstPath, info.Mode())
               }

               return copyFile(path, dstPath)
           })
       }
       ```

    6. 实现 rollback：
       ```go
       func rollback(backupDir, targetDir string) error {
           files, _ := filepath.Glob(filepath.Join(backupDir, "*"))
           for _, src := range files {
               dst := filepath.Join(targetDir, filepath.Base(src))
               if err := copyFile(src, dst); err != nil {
                   return err
               }
           }
           return nil
       }
       ```

    7. 实现 launchNewVersion：
       ```go
       func launchNewVersion(execPath string) error {
           cmd := exec.Command(execPath)
           # Windows 下隐藏控制台
           cmd.SysProcAttr = &syscall.SysProcAttr{
               CreationFlags: 0x08000000,
           }
           return cmd.Start()
       }
       ```

    8. 添加 copyFile 辅助函数。
  </action>
  <verify>
    ```bash
    cd C:/WorkSpace/Go2Hell/src/github.com/allanpk716/ai-commit-hub
    go build -o tmp/updater.exe ./pkg/update/updater
    ```
  </verify>
  <done>
    - 所有核心函数实现完整
    - 更新器可以独立编译
    - 编译成功
  </done>
</task>

<task type="auto">
  <name>任务 3: 修改 installer.go 支持嵌入更新器</name>
  <files>pkg/update/installer.go</files>
  <action>
    修改 `pkg/update/installer.go`，使用 embed 嵌入更新器：

    1. 添加 embed 指令：
       ```go
       //go:embed updater/updater.exe
       var embeddedUpdater []byte
       ```
       注意：这需要 updater.exe 预先构建。需要添加构建步骤。

    2. 修改 NewInstaller 不再查找外部更新器：
       ```go
       func NewInstaller() *Installer {
           return &Installer{}
       }
       ```

    3. 添加 ExtractUpdater 方法：
       ```go
       func (i *Installer) ExtractUpdater() (string, error) {
           tmpDir := os.TempDir()
           updaterPath := filepath.Join(tmpDir, "ai-commit-hub-updater.exe")

           // 写入嵌入的更新器
           if err := os.WriteFile(updaterPath, embeddedUpdater, 0755); err != nil {
               return "", fmt.Errorf("写入更新器失败: %w", err)
           }

           return updaterPath, nil
       }
       ```

    4. 修改 Install 方法：
       ```go
       func (i *Installer) Install(updateZipPath string) error {
           // 释放更新器
           updaterPath, err := i.ExtractUpdater()
           if err != nil {
               return err
           }

           // 获取主程序信息
           pid := os.Getpid()
           execPath, _ := os.Executable()
           targetDir := filepath.Dir(execPath)

           // 启动更新器
           cmd := exec.Command(updaterPath,
               "--source", updateZipPath,
               "--target", targetDir,
               "--pid", strconv.Itoa(pid),
               "--exec", execPath,
           )

           // Windows 下隐藏控制台
           if runtime.GOOS == "windows" {
               cmd.SysProcAttr = &windows.SysProcAttr{
                   CreationFlags: 0x08000000,
               }
           }

           if err := cmd.Start(); err != nil {
               return fmt.Errorf("启动更新器失败: %w", err)
           }

           return nil
       }
       ```

    5. 添加构建说明注释：
       ```go
       // 注意：更新器需要在嵌入前单独构建
       // 构建命令：go build -o pkg/update/updater/updater.exe ./pkg/update/updater
       // 或使用 Makefile/Wails 构建脚本自动构建
       ```

    **重要**：需要在构建脚本中添加预构建更新器的步骤。
  </action>
  <verify>
    ```bash
    cd C:/WorkSpace/Go2Hell/src/github.com/allanpk716/ai-commit-hub
    go build ./pkg/update/updater -o pkg/update/updater/updater.exe
    go build -o tmp/ai-commit-hub.exe .
    ```
  </verify>
  <done>
    - installer.go 使用 embed 嵌入更新器
    - ExtractUpdater 方法正确释放更新器到临时目录
    - Install 方法启动嵌入的更新器
    - 编译成功（需先构建 updater.exe）
  </done>
</task>

<task type="auto">
  <name>任务 4: 更新构建脚本</name>
  <files>.github/workflows/build.yml, Makefile</files>
  <action>
    更新构建流程以包含更新器预构建：

    1. 修改 `.github/workflows/build.yml`：
       - 在主程序构建前添加步骤：
         ```yaml
         - name: Build Updater
           shell: bash
           run: |
             go build -o pkg/update/updater/updater.exe ./pkg/update/updater
         ```
       - 确保此步骤在 `wails build` 之前

    2. 如果存在 Makefile，添加 updater 目标：
       ```makefile
       .PHONY: updater
       updater:
           go build -o pkg/update/updater/updater.exe ./pkg/update/updater

       build: updater
           wails build
       ```

    3. 如果使用 wails.toml，确保构建顺序正确。

    **注意**：这是可选任务，如果没有 Makefile 或需要修改 workflow，可以跳过或简化。
  </action>
  <verify>
    ```bash
    cd C:/WorkSpace/Go2Hell/src/github.com/allanpk716/ai-commit-hub
    # 手动验证构建顺序
    go build -o pkg/update/updater/updater.exe ./pkg/update/updater && echo "Updater OK"
    ```
  </verify>
  <done>
    - 构建流程包含更新器预构建步骤
    - 更新器在主程序构建前完成
    - 嵌入的更新器是最新版本
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
    完整的外部更新器程序：
    - pkg/update/updater/main.go：更新器入口
    - pkg/update/updater/updater.go：核心功能
    - pkg/update/installer.go：嵌入和释放更新器
    - 构建脚本更新
  </what-built>
  <how-to-verify>
    验证步骤：
    1. 构建更新器：
       ```bash
       cd C:/WorkSpace/Go2Hell/src/github.com/allanpk716/ai-commit-hub
       go build -o tmp/updater.exe ./pkg/update/updater
       ```
    2. 手动测试更新器：
       ```bash
       ./tmp/updater.exe --source=test.zip --target=tmp/target --pid=1234
       ```
    3. 构建主程序：
       ```bash
       go build -o tmp/ai-commit-hub.exe .
       ```
    4. 验证更新器被嵌入：
       - 检查二进制文件中是否包含 "updater" 字符串
       - 运行时检查是否能正确释放更新器
    5. 完整测试更新流程：
       - 下载测试 ZIP 包
       - 触发更新
       - 观察更新器是否正确启动和执行
    6. 验证更新器窗口显示中文信息
  </how-to-verify>
  <resume-signal>
    验证通过后输入 "approved"，如有问题请描述具体问题。
  </resume-signal>
</task>

</tasks>

<verification>
整体验证标准：
1. 更新器作为独立程序构建成功
2. 更新器接受命令行参数并正确解析
3. 更新器等待主程序退出
4. 更新器解压 ZIP 并验证内容
5. 更新器备份旧版本
6. 更新器替换文件，失败时回滚
7. 更新完成后启动新版本
8. 更新器嵌入主程序中
</verification>

<success_criteria>
- 独立的更新器程序
- embed 嵌入更新器到主程序
- 更新器支持解压、备份、替换、回滚
- 更新器显示中文界面
- 更新完成后自动启动新版本
- 构建流程包含更新器预构建
</success_criteria>

<output>
完成后创建 `.planning/phases/04-auto-update-system/04-03-SUMMARY.md`
</output>
