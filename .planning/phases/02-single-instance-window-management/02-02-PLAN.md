---
phase: 02-single-instance-window-management
plan: 02
type: execute
wave: 1
depends_on: []
files_modified: [pkg/models/window_state.go, pkg/repository/window_state_repository.go, app.go, pkg/repository/db.go]
autonomous: true
user_setup: []

must_haves:
  truths:
    - "窗口位置和大小在下次启动时自动恢复"
    - "窗口关闭时保存最后状态(位置、大小、最大化状态)"
    - "保存的状态存储在 SQLite 数据库中"
    - "如果保存的数据无效(位置超出屏幕),使用系统默认值"
  artifacts:
    - path: "pkg/models/window_state.go"
      provides: "WindowState 模型"
      min_lines: 20
    - path: "pkg/repository/window_state_repository.go"
      provides: "窗口状态数据访问层"
      min_lines: 30
      exports: ["NewWindowStateRepository", "GetByKey", "Save"]
    - path: "app.go"
      provides: "窗口状态保存和恢复逻辑"
      contains: "saveWindowState|restoreWindowState"
    - path: "pkg/repository/db.go"
      provides: "数据库迁移入口"
      contains: "WindowState"
  key_links:
    - from: "app.go"
      to: "pkg/repository/window_state_repository.go"
      via: "窗口状态保存和恢复"
      pattern: "windowStateRepo\\.(GetByKey|Save)"
    - from: "app.go"
      to: "runtime"
      via: "WindowSetPosition, WindowSetSize, WindowGetSize, WindowGetPosition"
      pattern: "runtime\\.(WindowSetPosition|WindowSetSize|WindowGetSize|WindowGetPosition|WindowIsMaximised|WindowMaximise)"
    - from: "pkg/repository/db.go"
      to: "pkg/models/window_state.go"
      via: "AutoMigrate"
      pattern: "AutoMigrate.*WindowState"
---

<objective>
实现窗口状态持久化功能,保存窗口位置、大小和最大化状态到数据库,下次启动时自动恢复。

Purpose: 记住用户的窗口偏好设置,提升用户体验。窗口位置和大小在重启后能够恢复,避免每次都需要手动调整窗口。

Output: 完整的窗口状态持久化系统,包括数据模型、Repository 和应用集成。
</objective>

<execution_context>
@C:\Users\allan716\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\allan716\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-single-instance-window-management/02-CONTEXT.md
@.planning/phases/02-single-instance-window-management/02-RESEARCH.md

@pkg/models/git_project.go
@pkg/repository/db.go
@pkg/repository/git_project_repository.go
@app.go
</context>

<tasks>

<task type="auto">
  <name>任务 1: 创建 WindowState 模型</name>
  <files>pkg/models/window_state.go</files>
  <action>
    创建新文件 pkg/models/window_state.go,定义 WindowState 结构体:

    ```go
    package models

    import "gorm.io/gorm"

    // WindowState 窗口状态模型
    type WindowState struct {
        gorm.Model
        Key       string `gorm:"uniqueIndex;not null;size:100"` // 配置键(如 "window.main")
        X         int    `gorm:"not null"`                       // 窗口 X 坐标
        Y         int    `gorm:"not null"`                       // 窗口 Y 坐标
        Width     int    `gorm:"not null"`                       // 窗口宽度
        Height    int    `gorm:"not null"`                       // 窗口高度
        Maximized bool   `gorm:"default:false"`                  // 是否最大化
        MonitorID string `gorm:"size:50"`                        // 显示器编号(可选)
    }

    // TableName 指定表名
    func (WindowState) TableName() string {
        return "window_states"
    }
    ```

    注意:
    - 遵循 GORM 命名约定(表名复数形式 window_states)
    - 使用 snake_case 字段名
    - Key 字段添加 uniqueIndex 确保唯一性
    - 参考现有 models 代码风格(git_project.go)
  </action>
  <verify>cat pkg/models/window_state.go | grep -c "WindowState" 返回 > 0</verify>
  <done>pkg/models/window_state.go 文件存在,包含 WindowState 结构体和 TableName 方法</done>
</task>

<task type="auto">
  <name>任务 2: 创建 WindowStateRepository</name>
  <files>pkg/repository/window_state_repository.go</files>
  <action>
    创建新文件 pkg/repository/window_state_repository.go,实现数据访问层:

    ```go
    package repository

    import (
        "github.com/allanpk716/ai-commit-hub/pkg/models"
        "gorm.io/gorm"
    )

    // WindowStateRepository 窗口状态数据访问层
    type WindowStateRepository struct {
        db *gorm.DB
    }

    // NewWindowStateRepository 创建 WindowStateRepository 实例
    func NewWindowStateRepository() *WindowStateRepository {
        return &WindowStateRepository{
            db: GetDB(),
        }
    }

    // GetByKey 根据 key 获取窗口状态
    func (r *WindowStateRepository) GetByKey(key string) (*models.WindowState, error) {
        var state models.WindowState
        err := r.db.Where("key = ?", key).First(&state).Error
        if err != nil {
            return nil, err
        }
        return &state, nil
    }

    // Save 保存或更新窗口状态(Upsert)
    func (r *WindowStateRepository) Save(state *models.WindowState) error {
        return r.db.Save(state).Error
    }

    // DeleteByKey 删除指定 key 的窗口状态
    func (r *WindowStateRepository) DeleteByKey(key string) error {
        return r.db.Where("key = ?", key).Delete(&models.WindowState{}).Error
    }
    ```

    注意:
    - 使用 GetDB() 获取数据库实例(与现有 repository 一致)
    - 使用 GORM 的 Save 方法自动处理 Upsert 逻辑
    - 参考 git_project_repository.go 的代码风格
  </action>
  <verify>cat pkg/repository/window_state_repository.go | grep -c "WindowStateRepository" 返回 > 0</verify>
  <done>pkg/repository/window_state_repository.go 文件存在,包含 GetByKey 和 Save 方法</done>
</task>

<task type="auto">
  <name>任务 3: 更新数据库迁移</name>
  <files>pkg/repository/db.go</files>
  <action>
    修改 pkg/repository/db.go 的 InitializeDatabase 函数:

    1. 在 AutoMigrate 调用中添加 &models.WindowState{}
    2. 修改前: AutoMigrate(&models.GitProject{}, &models.CommitHistory{}, &models.UpdatePreferences{})
    3. 修改后: AutoMigrate(&models.GitProject{}, &models.CommitHistory{}, &models.UpdatePreferences{}, &models.WindowState{})

    注意:
    - 确保添加 models.WindowState 的导入(已存在)
    - 迁移会在应用启动时自动创建 window_states 表
  </action>
  <verify>grep "WindowState" pkg/repository/db.go | grep AutoMigrate</verify>
  <done>pkg/repository/db.go 的 AutoMigrate 包含 models.WindowState</done>
</task>

<task type="auto">
  <name>任务 4: 实现窗口状态保存逻辑</name>
  <files>app.go</files>
  <action>
    1. 在 App 结构体中添加 windowStateRepo 字段:
       ```go
       windowStateRepo *repository.WindowStateRepository
       ```

    2. 在 startup 方法中初始化 repository(在 database 初始化之后):
       ```go
       a.windowStateRepo = repository.NewWindowStateRepository()
       ```

    3. 添加 saveWindowState 方法:
       ```go
       // saveWindowState 保存当前窗口状态
       func (a *App) saveWindowState() error {
           if a.windowStateRepo == nil {
               return nil // repository 未初始化,跳过
           }

           // 获取当前窗口状态
           x, y := runtime.WindowGetPosition(a.ctx)
           width, height := runtime.WindowGetSize(a.ctx)
           isMaximized := runtime.WindowIsMaximised(a.ctx)

           state := &models.WindowState{
               Key:       "window.main",
               X:         x,
               Y:         y,
               Width:     width,
               Height:    height,
               Maximized: isMaximized,
           }

           // 保存到数据库
           if err := a.windowStateRepo.Save(state); err != nil {
               return err
           }

           logger.Info("窗口状态已保存")
           return nil
       }
       ```

    4. 修改现有的 onBeforeClose 方法,在关闭前保存状态:
       - 在方法开头调用 a.saveWindowState()
       - 使用 defer recover 确保保存失败不会阻塞关闭
       - 记录错误但不阻止关闭流程

    注意:
    - 在现有的 onBeforeClose 中集成保存逻辑
    - 保留现有的托盘隐藏逻辑
    - 保存失败时应记录错误但不阻塞关闭
  </action>
  <verify>grep -n "saveWindowState" app.go 返回方法定义和调用</verify>
  <done>app.go 包含 saveWindowState 方法,在 onBeforeClose 中被调用</done>
</task>

<task type="auto">
  <name>任务 5: 实现窗口状态恢复逻辑</name>
  <files>app.go</files>
  <action>
    1. 添加 isPositionValid 方法验证窗口位置:
       ```go
       // isPositionValid 验证窗口位置是否有效
       func (a *App) isPositionValid(x, y, width, height int) bool {
           const (
               minWidth  = 400
               minHeight = 300
               maxCoord  = 10000
           )

           return x >= 0 && y >= 0 && width >= minWidth && height >= minHeight &&
               x < maxCoord && y < maxCoord
       }
       ```

    2. 添加 restoreWindowState 方法:
       ```go
       // restoreWindowState 恢复窗口状态
       func (a *App) restoreWindowState() error {
           if a.windowStateRepo == nil {
               return nil // repository 未初始化,使用默认位置
           }

           state, err := a.windowStateRepo.GetByKey("window.main")
           if err != nil {
               logger.Info("首次启动,使用默认窗口位置")
               return nil // 无记录,使用默认位置
           }

           // 验证窗口位置是否有效
           if !a.isPositionValid(state.X, state.Y, state.Width, state.Height) {
               logger.Warn("保存的窗口位置无效,使用默认位置")
               return nil
           }

           // 恢复窗口位置和大小
           runtime.WindowSetPosition(a.ctx, state.X, state.Y)
           runtime.WindowSetSize(a.ctx, state.Width, state.Height)

           // 恢复最大化状态
           if state.Maximized {
               runtime.WindowMaximise(a.ctx)
           }

           logger.Info("窗口状态已恢复")
           return nil
       }
       ```

    3. 在 startup 方法末尾调用恢复逻辑:
       - 在所有初始化完成后调用 a.restoreWindowState()
       - 记录错误但不阻塞启动

    注意:
    - 恢复失败时使用默认窗口位置,不影响应用启动
    - 最大化状态要在设置位置和大小后应用
    - 验证位置防止窗口"丢失"在屏幕外
  </action>
  <verify>grep -n "restoreWindowState" app.go 返回方法定义和调用</verify>
  <done>app.go 包含 restoreWindowState 方法,在 startup 中被调用</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>完整的窗口状态持久化功能,包括模型、Repository 和应用集成</what-built>
  <how-to-verify>
    1. 构建: wails build
    2. 启动应用
    3. 调整窗口位置和大小(如移动到右下角,缩小窗口)
    4. 关闭应用(退出)
    5. 重新启动应用
    6. 验证窗口位置和大小是否恢复到上次的设置

    预期行为:
    - 窗口在相同位置和大小下启动
    - 最大化状态能够恢复
    - 数据库中 window_states 表有记录
  </how-to-verify>
  <resume-signal>输入 "approved" 确认功能正常,或描述问题</resume-signal>
</task>

</tasks>

<verification>
1. 编译成功,无错误
2. pkg/models/window_state.go 文件存在并包含 WindowState 模型
3. pkg/repository/window_state_repository.go 文件存在并包含数据访问方法
4. pkg/repository/db.go 的 AutoMigrate 包含 WindowState
5. app.go 包含 saveWindowState 和 restoreWindowState 方法
6. startup 中初始化 windowStateRepo 并调用 restoreWindowState
7. onBeforeClose 中调用 saveWindowState
8. 测试验证窗口状态能够正确保存和恢复
</verification>

<success_criteria>
1. 窗口位置和大小在下次启动时自动恢复
2. 窗口关闭时保存最后状态(位置、大小、最大化状态)
3. 保存的状态存储在 SQLite 数据库中
4. 如果保存的数据无效(位置超出屏幕),使用系统默认值
</success_criteria>

<output>
After completion, create `.planning/phases/02-single-instance-window-management/02-02-SUMMARY.md`
</output>
