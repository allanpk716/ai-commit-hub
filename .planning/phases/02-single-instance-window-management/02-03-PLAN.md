---
phase: 02-single-instance-window-management
plan: 03
type: execute
wave: 2
depends_on: ["02"]
files_modified: [app.go]
autonomous: false
user_setup: []

must_haves:
  truths:
    - "窗口位置和大小在下次启动时自动恢复"
    - "窗口关闭时保存最后状态(位置、大小、最大化状态)"
    - "如果保存的数据无效(位置超出屏幕),使用系统默认值"
    - "如果原显示器不存在,使用系统默认位置"
  artifacts:
    - path: "app.go"
      provides: "窗口状态保存和恢复逻辑"
      contains: "saveWindowState|restoreWindowState"
  key_links:
    - from: "app.go"
      to: "pkg/repository/window_state_repository.go"
      via: "窗口状态保存和恢复"
      pattern: "windowStateRepo\\.(GetByKey|Save)"
    - from: "app.go"
      to: "runtime"
      via: "WindowSetPosition, WindowSetSize, WindowGetSize, WindowGetPosition"
      pattern: "runtime\\.(WindowSetPosition|WindowSetSize|WindowGetSize|WindowGetPosition|WindowIsMaximised|WindowMaximise)"
---

<objective>
集成窗口状态持久化到应用层,实现窗口状态的保存和恢复功能。

Purpose: 利用 02-02 创建的数据层,在应用启动时恢复窗口状态,在关闭时保存窗口状态,提供完整的用户体验。

Output: 应用层集成的窗口状态保存和恢复功能。
</objective>

<execution_context>
@C:\Users\allan716\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\allan716\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-single-instance-window-management/02-CONTEXT.md
@.planning/phases/02-single-instance-window-management/02-RESEARCH.md
@.planning/phases/02-single-instance-window-management/02-02-SUMMARY.md

@app.go
@pkg/repository/window_state_repository.go
</context>

<tasks>

<task type="auto">
  <name>任务 1: 实现窗口状态保存逻辑</name>
  <files>app.go</files>
  <action>
    1. 在 App 结构体中添加 windowStateRepo 字段:
       ```go
       windowStateRepo *repository.WindowStateRepository
       ```

    2. 在 startup 方法中初始化 repository(在 database 初始化之后):
       ```go
       a.windowStateRepo = repository.NewWindowStateRepository()
       ```

    3. 添加 saveWindowState 方法:
       ```go
       // saveWindowState 保存当前窗口状态
       func (a *App) saveWindowState() error {
           if a.windowStateRepo == nil {
               return nil // repository 未初始化,跳过
           }

           // 获取当前窗口状态
           x, y := runtime.WindowGetPosition(a.ctx)
           width, height := runtime.WindowGetSize(a.ctx)
           isMaximized := runtime.WindowIsMaximised(a.ctx)

           state := &models.WindowState{
               Key:       "window.main",
               X:         x,
               Y:         y,
               Width:     width,
               Height:    height,
               Maximized: isMaximized,
           }

           // 保存到数据库
           if err := a.windowStateRepo.Save(state); err != nil {
               return err
           }

           logger.Info("窗口状态已保存")
           return nil
       }
       ```

    4. 修改现有的 onBeforeClose 方法,在关闭前保存状态:
       - 在方法开头调用 a.saveWindowState()
       - 使用 defer recover 确保保存失败不会阻塞关闭
       - 记录错误但不阻止关闭流程

    注意:
    - 在现有的 onBeforeClose 中集成保存逻辑
    - 保留现有的托盘隐藏逻辑
    - 保存失败时应记录错误但不阻塞关闭
  </action>
  <verify>grep -n "saveWindowState" app.go 返回方法定义和调用</verify>
  <done>app.go 包含 saveWindowState 方法,在 onBeforeClose 中被调用</done>
</task>

<task type="auto">
  <name>任务 2: 实现窗口状态恢复逻辑</name>
  <files>app.go</files>
  <action>
    1. 添加 isPositionValid 方法验证窗口位置:
       ```go
       // isPositionValid 验证窗口位置是否有效
       func (a *App) isPositionValid(x, y, width, height int) bool {
           const (
               minWidth  = 400
               minHeight = 300
               maxCoord  = 10000
           )

           return x >= 0 && y >= 0 && width >= minWidth && height >= minHeight &&
               x < maxCoord && y < maxCoord
       }
       ```

    2. 添加 restoreWindowState 方法:
       ```go
       // restoreWindowState 恢复窗口状态
       func (a *App) restoreWindowState() error {
           if a.windowStateRepo == nil {
               return nil // repository 未初始化,使用默认位置
           }

           state, err := a.windowStateRepo.GetByKey("window.main")
           if err != nil {
               logger.Info("首次启动,使用默认窗口位置")
               return nil // 无记录,使用默认位置
           }

           // 验证窗口位置是否有效
           if !a.isPositionValid(state.X, state.Y, state.Width, state.Height) {
               logger.Warn("保存的窗口位置无效,使用默认位置")
               return nil
           }

           // 恢复窗口位置和大小
           runtime.WindowSetPosition(a.ctx, state.X, state.Y)
           runtime.WindowSetSize(a.ctx, state.Width, state.Height)

           // 恢复最大化状态
           if state.Maximized {
               runtime.WindowMaximise(a.ctx)
           }

           logger.Info("窗口状态已恢复")
           return nil
       }
       ```

    3. 在 startup 方法末尾调用恢复逻辑:
       - 在所有初始化完成后调用 a.restoreWindowState()
       - 记录错误但不阻塞启动

    注意:
    - 恢复失败时使用默认窗口位置,不影响应用启动
    - 最大化状态要在设置位置和大小后应用
    - 验证位置防止窗口"丢失"在屏幕外
    - 多显示器处理: 保存的 MonitorID 可用于未来增强,当前恢复逻辑在位置无效时使用默认值
  </action>
  <verify>grep -n "restoreWindowState" app.go 返回方法定义和调用</verify>
  <done>app.go 包含 restoreWindowState 方法,在 startup 中被调用</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>完整的窗口状态持久化功能,包括应用层集成和数据层</what-built>
  <how-to-verify>
    1. 构建: wails build
    2. 启动应用
    3. 调整窗口位置和大小(如移动到右下角,缩小窗口)
    4. 关闭应用(退出)
    5. 重新启动应用
    6. 验证窗口位置和大小是否恢复到上次的设置

    预期行为:
    - 窗口在相同位置和大小下启动
    - 最大化状态能够恢复
    - 数据库中 window_states 表有记录
  </how-to-verify>
  <resume-signal>输入 "approved" 确认功能正常,或描述问题</resume-signal>
</task>

</tasks>

<verification>
1. 编译成功,无错误
2. app.go 包含 saveWindowState 和 restoreWindowState 方法
3. startup 中初始化 windowStateRepo 并调用 restoreWindowState
4. onBeforeClose 中调用 saveWindowState
5. 测试验证窗口状态能够正确保存和恢复
</verification>

<success_criteria>
1. 窗口位置和大小在下次启动时自动恢复
2. 窗口关闭时保存最后状态(位置、大小、最大化状态)
3. 如果保存的数据无效(位置超出屏幕),使用系统默认值
4. 如果原显示器不存在,使用系统默认位置
</success_criteria>

<output>
After completion, create `.planning/phases/02-single-instance-window-management/02-03-SUMMARY.md`
</output>
