---
phase: 02-single-instance-window-management
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [main.go, app.go]
autonomous: true
user_setup: []

must_haves:
  truths:
    - "应用启动时自动检测是否已有实例运行"
    - "检测到多实例时，自动激活现有窗口到前台"
    - "使用 Wails 内置 SingleInstanceLock 机制"
    - "第二个实例启动时静默退出，不显示任何通知"
  artifacts:
    - path: "main.go"
      provides: "SingleInstanceLock 配置"
      contains: "SingleInstanceLock"
    - path: "app.go"
      provides: "OnSecondInstanceLaunch 回调"
      contains: "onSecondInstanceLaunch"
  key_links:
    - from: "main.go"
      to: "app.go"
      via: "OnSecondInstanceLaunch: app.onSecondInstanceLaunch"
      pattern: "OnSecondInstanceLaunch.*app\\.onSecondInstanceLaunch"
    - from: "app.go"
      to: "runtime"
      via: "WindowShow + WindowUnminimise"
      pattern: "runtime\\.(WindowShow|WindowUnminimise)"
---

<objective>
实现单实例锁定机制,防止应用多实例运行,当检测到第二个实例启动时自动激活现有窗口到前台。

Purpose: 确保同一时间只有一个应用实例运行,避免配置冲突和资源浪费。用户双击应用图标时,如果已有实例运行,会自动激活现有窗口而非打开新窗口。

Output: 配置好 SingleInstanceLock 的 Wails 应用,实现静默窗口激活。
</objective>

<execution_context>
@C:\Users\allan716\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\allan716\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-single-instance-window-management/02-CONTEXT.md
@.planning/phases/02-single-instance-window-management/02-RESEARCH.md

@main.go
@app.go
</context>

<tasks>

<task type="auto">
  <name>任务 1: 配置 SingleInstanceLock 选项</name>
  <files>main.go</files>
  <action>
    1. 在 main.go 的 wails.Run 配置中添加 SingleInstanceLock 选项
    2. 使用 UUID 作为 UniqueId,格式: "e3984e08-28dc-4e3d-b70a-45e961589cdc"
    3. 配置 OnSecondInstanceLaunch 回调为 app.onSecondInstanceLaunch

    注意:
    - SingleInstanceLock 应该放在 OnStartup、OnShutdown、OnBeforeClose 同级
    - 不要导入 github.com/google/uuid,直接使用固定 UUID 字符串
    - 参考代码结构:
      ```go
      SingleInstanceLock: &options.SingleInstanceLock{
          UniqueId: "e3984e08-28dc-4e3d-b70a-45e961589cdc",
          OnSecondInstanceLaunch: app.onSecondInstanceLaunch,
      },
      ```
  </action>
  <verify>grep -n "SingleInstanceLock" main.go 返回配置行</verify>
  <done>main.go 包含完整的 SingleInstanceLock 配置,包含 UniqueId 和 OnSecondInstanceLaunch</done>
</task>

<task type="auto">
  <name>任务 2: 实现 onSecondInstanceLaunch 回调</name>
  <files>app.go</files>
  <action>
    1. 在 App 结构体中确保有 ctx context.Context 字段(已存在)
    2. 在 app.go 中添加 onSecondInstanceLaunch 方法,签名为:
       ```go
       func (a *App) onSecondInstanceLaunch(secondInstanceData options.SecondInstanceData)
       ```
    3. 在方法中调用 runtime.WindowUnminimise(a.ctx) 恢复最小化窗口
    4. 在方法中调用 runtime.WindowShow(a.ctx) 显示并激活窗口到前台
    5. 可选: 记录日志(仅调试级别,不显示给用户)

    注意:
    - 回调必须静默激活窗口,不显示任何通知或对话框
    - 必须同时调用 WindowUnminimise 和 WindowShow
    - 先调用 WindowUnminimise 恢复最小化窗口,再调用 WindowShow 激活到前台
    - 如果需要处理第二个实例的参数,可以记录到日志但不做额外处理
    - 不需要导入新的包,使用现有的 runtime 包即可
  </action>
  <verify>grep -n "onSecondInstanceLaunch" app.go 返回方法定义</verify>
  <done>app.go 包含 onSecondInstanceLaunch 方法,调用 runtime.WindowUnminimise 和 runtime.WindowShow</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>完整的单实例锁定功能,包括 SingleInstanceLock 配置和窗口激活回调</what-built>
  <how-to-verify>
    1. 构建: wails build
    2. 启动应用第一个实例
    3. 再次双击 exe 启动第二个实例
    4. 观察现有窗口是否被激活到前台(而非打开新窗口)
    5. 确认没有任何错误对话框或通知显示

    预期行为:
    - 第二个实例启动后立即退出
    - 现有窗口从最小化状态恢复并激活到前台
    - 整个过程静默无提示
  </how-to-verify>
  <resume-signal>输入 "approved" 确认功能正常,或描述问题</resume-signal>
</task>

</tasks>

<verification>
1. 编译成功,无错误
2. SingleInstanceLock 配置存在于 main.go
3. onSecondInstanceLaunch 回调存在于 app.go
4. 回调正确调用 WindowUnminimise 和 WindowShow
5. 测试验证单实例功能正常工作
</verification>

<success_criteria>
1. 应用启动时自动检测是否已有实例运行
2. 检测到多实例时,自动激活现有窗口到前台
3. 第二个实例静默退出,不显示任何通知
4. 使用 Wails 内置 SingleInstanceLock 机制
</success_criteria>

<output>
After completion, create `.planning/phases/02-single-instance-window-management/02-01-SUMMARY.md`
</output>
