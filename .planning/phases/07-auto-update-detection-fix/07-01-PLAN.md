---
phase: 07-auto-update-detection-fix
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - go.mod
  - pkg/service/update_service.go
  - pkg/service/update_fallback.go
autonomous: true

must_haves:
  truths:
    - "应用启动时能够正确检测 GitHub Releases 最新版本"
    - "GitHub API 失败时自动降级到 Atom feed 获取版本信息"
    - "版本比较逻辑正确处理预发布版本（alpha/beta/rc）"
    - "Atom feed 解析失败时记录详细日志"
  artifacts:
    - path: "pkg/service/update_fallback.go"
      provides: "Atom feed 降级实现"
      min_lines: 80
    - path: "go.mod"
      contains: "github.com/mmcdole/gofeed"
    - path: "pkg/service/update_service.go"
      exports: ["CheckForUpdates", "checkViaAPI", "checkViaAtomFeed"]
  key_links:
    - from: "pkg/service/update_service.go"
      to: "https://github.com/allanpk716/ai-commit-hub/releases.atom"
      via: "http.Client with 10s timeout"
      pattern: "httpClient\.Get|ParseURLWithContext"
---

<objective>
实现 GitHub API + Atom feed 混合降级策略，解决 GitHub Releases 版本检测失败问题。当 GitHub API 因速率限制或网络问题失败时，自动降级到 Atom feed 获取版本信息，确保版本检测的可靠性。

Purpose: 用户反馈 GitHub Releases 版本检测经常失败，应用无法正确获取最新版本信息。通过实现混合降级策略，提高版本检测的可用性和稳定性。

Output: 增强的 UpdateService，支持 GitHub API + Atom feed 双通道版本检测。
</objective>

<execution_context>
@C:\Users\allan716\.claude\get-shit-done\workflows\execute-plan.md
@C:\Users\allan716\.claude\get-shit-done\templates\summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-auto-update-detection-fix/07-CONTEXT.md
@.planning/phases/07-auto-update-detection-fix/07-RESEARCH.md
@pkg/service/update_service.go
@pkg/models/update_info.go
@go.mod
</context>

<tasks>

<task type="auto">
  <name>Task 1: 添加 gofeed 依赖</name>
  <files>go.mod</files>
  <action>
    添加 gofeed 库到项目依赖：

    1. 运行命令：go get github.com/mmcdole/gofeed
    2. 运行命令：go mod tidy

    不要修改 go.mod 手动添加，使用 go get 命令确保依赖正确解析。
  </action>
  <verify>grep -q "github.com/mmcdole/gofeed" go.mod && go build ./...</verify>
  <done>gofeed 库已添加到 go.mod 且项目可以成功编译</done>
</task>

<task type="auto">
  <name>Task 2: 创建 Atom feed 降级实现</name>
  <files>pkg/service/update_fallback.go</files>
  <action>
    创建新文件 pkg/service/update_fallback.go，实现 Atom feed 降级逻辑：

    ```go
    package service

    import (
        "context"
        "fmt"
        "regexp"
        "strings"
        "time"

        "github.com/WQGroup/logger"
        "github.com/allanpk716/ai-commit-hub/pkg/models"
        "github.com/allanpk716/ai-commit-hub/pkg/version"
        "github.com/mmcdole/gofeed"
        "golang.org/x/mod/semver"
    )

    // checkViaAtomFeed 通过 GitHub Atom feed 获取版本信息（降级方案）
    func (s *UpdateService) checkViaAtomFeed() (*models.UpdateInfo, error) {
        // 创建 10 秒超时的 context
        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()

        url := fmt.Sprintf("https://github.com/%s/releases.atom", s.repo)
        logger.WithField("url", url).Info("尝试通过 Atom feed 获取版本")

        fp := gofeed.NewParser()
        fp.Client = s.httpClient // 复用已有的 http.Client

        feed, err := fp.ParseURLWithContext(url, ctx)
        if err != nil {
            logger.Warnf("解析 Atom feed 失败: %v", err)
            return nil, fmt.Errorf("解析 Atom feed 失败: %w", err)
        }

        if len(feed.Items) == 0 {
            logger.Warn("Atom feed 无内容")
            return nil, fmt.Errorf("Atom feed 无内容")
        }

        // 取第一个 item（最新 release）
        latestItem := feed.Items[0]

        logger.WithFields(map[string]interface{}{
            "title":     latestItem.Title,
            "published": latestItem.PublishedParsed,
        }).Info("Atom feed 解析成功")

        // 从 title 提取版本号
        latestVersion := s.extractVersionFromFeed(latestItem.Title)
        if latestVersion == "" {
            logger.Warnf("无法从 feed title 提取版本号: %s", latestItem.Title)
            return nil, fmt.Errorf("无法从 feed title 提取版本号")
        }

        currentVersion := version.GetVersion()

        // 比较版本
        hasUpdate := s.compareVersions(latestVersion, currentVersion)

        // 构造下载 URL
        downloadURL := s.constructDownloadURL(latestVersion)

        // 从 category 检查是否为预发布版本
        isPrerelease := s.isPrereleaseFromFeed(latestItem)
        prereleaseType := s.extractPrereleaseType(latestVersion)

        return &models.UpdateInfo{
            HasUpdate:      hasUpdate,
            LatestVersion:  latestVersion,
            CurrentVersion: currentVersion,
            ReleaseNotes:   latestItem.Content,
            PublishedAt:    *latestItem.PublishedParsed,
            DownloadURL:    downloadURL,
            AssetName:      s.getAssetNameFromVersion(latestVersion),
            Size:           0, // Atom feed 不提供文件大小
            IsPrerelease:   isPrerelease,
            PrereleaseType: prereleaseType,
        }, nil
    }

    // extractVersionFromFeed 从 feed title 中提取版本号
    func (s *UpdateService) extractVersionFromFeed(title string) string {
        // 匹配 v1.2.3 或 1.2.3 格式，包括预发布版本
        re := regexp.MustCompile(`v?\d+\.\d+\.\d+(-[0-9A-Za-z-]+)?`)
        match := re.FindString(title)
        if match == "" {
            return ""
        }

        // 确保以 v 开头（semver 标准格式）
        if !strings.HasPrefix(match, "v") {
            match = "v" + match
        }

        // 验证是否为有效的 semver
        if semver.IsValid(match) {
            return match
        }

        logger.Warnf("提取的版本号无效: %s", match)
        return ""
    }

    // constructDownloadURL 构造下载 URL
    func (s *UpdateService) constructDownloadURL(version string) string {
        // 标准化版本号（移除 v 前缀用于文件名）
        versionWithoutV := strings.TrimPrefix(version, "v")
        assetName := fmt.Sprintf("ai-commit-hub-windows-amd64-%s.zip", version)
        return fmt.Sprintf("https://github.com/%s/releases/download/%s/%s", s.repo, version, assetName)
    }

    // getAssetNameFromVersion 从版本号构造资源文件名
    func (s *UpdateService) getAssetNameFromVersion(version string) string {
        versionWithoutV := strings.TrimPrefix(version, "v")
        return fmt.Sprintf("ai-commit-hub-windows-amd64-%s.zip", versionWithoutV)
    }

    // isPrereleaseFromFeed 从 feed item 判断是否为预发布版本
    func (s *UpdateService) isPrereleaseFromFeed(item *gofeed.Item) bool {
        // 检查 title
        if strings.Contains(strings.ToLower(item.Title), "beta") ||
           strings.Contains(strings.ToLower(item.Title), "alpha") ||
           strings.Contains(strings.ToLower(item.Title), "rc") {
            return true
        }

        // 检查 category
        for _, category := range item.Categories {
            if strings.Contains(strings.ToLower(category), "prerelease") ||
               strings.Contains(strings.ToLower(category), "pre-release") {
                return true
            }
        }

        return false
    }
    ```

    注意：
    1. 复用 UpdateService 的 httpClient（已有 10s 超时配置）
    2. 使用 context.WithTimeout 确保超时控制
    3. 提取版本号后验证 semver 有效性
    4. 记录详细日志便于调试
  </action>
  <verify>go test -run TestCheckViaAtomFeed ./pkg/service/...</verify>
  <done>update_fallback.go 文件创建，包含完整的 Atom feed 解析逻辑</done>
</task>

<task type="auto">
  <name>Task 3: 修改 CheckForUpdates 实现混合降级</name>
  <files>pkg/service/update_service.go</files>
  <action>
    修改 pkg/service/update_service.go 中的 CheckForUpdates 方法，实现混合降级策略：

    1. 首先将现有的 fetchAllReleases 逻辑抽取到 checkViaAPI 方法
    2. 修改 CheckForUpdates 主流程，先尝试 API，失败后降级到 Atom feed

    修改 CheckForUpdates 方法（约第 64-139 行）：

    ```go
    // CheckForUpdates 检查更新（混合降级策略）
    func (s *UpdateService) CheckForUpdates() (*models.UpdateInfo, error) {
        // 测试模式：返回固定的更新信息
        if s.testMode {
            return s.getTestUpdateInfo()
        }

        logger.WithField("repo", s.repo).Info("检查更新")

        // 检查缓存（24小时内）
        s.mu.RLock()
        if s.cachedResult != nil && time.Since(s.lastCheck) < 24*time.Hour {
            logger.Info("使用缓存的更新检查结果")
            cached := s.cachedResult
            s.mu.RUnlock()
            return cached, nil
        }
        s.mu.RUnlock()

        // 优先使用 GitHub API
        info, err := s.checkViaAPI()
        if err == nil {
            // API 成功，更新缓存并返回
            s.updateCache(info)
            logger.Infof("通过 GitHub API 成功获取版本信息: hasUpdate=%v", info.HasUpdate)
            return info, nil
        }

        // API 失败，记录原因
        logger.Warnf("GitHub API 失败: %v", err)

        // 如果是速率限制错误且有缓存，返回缓存
        if s.isRateLimitError(err) && s.cachedResult != nil {
            logger.Warn("遇到速率限制错误，返回缓存结果")
            s.mu.RLock()
            cached := s.cachedResult
            s.mu.RUnlock()
            return cached, nil
        }

        // 降级到 Atom feed
        logger.Info("尝试降级到 Atom feed 获取版本信息")
        info, err = s.checkViaAtomFeed()
        if err != nil {
            // 两种方式都失败
            logger.Errorf("Atom feed 也失败了: %v", err)
            return nil, fmt.Errorf("无法获取版本信息：GitHub API 失败 (%w)，Atom feed 失败 (%v)", err, err)
        }

        // Atom feed 成功，更新缓存并返回
        s.updateCache(info)
        logger.Infof("通过 Atom feed 成功获取版本信息: hasUpdate=%v", info.HasUpdate)
        return info, nil
    }

    // checkViaAPI 通过 GitHub API 获取版本信息
    func (s *UpdateService) checkViaAPI() (*models.UpdateInfo, error) {
        // 获取所有 Releases
        releases, err := s.fetchAllReleases()
        if err != nil {
            return nil, fmt.Errorf("获取 Releases 失败: %w", err)
        }

        // 找到最新版本
        latestRelease := s.findLatestVersion(releases)
        if latestRelease == nil {
            return nil, fmt.Errorf("未找到有效的 Release")
        }

        currentVersion := version.GetVersion()
        latestVersion := latestRelease.TagName

        logger.WithFields(map[string]interface{}{
            "current": currentVersion,
            "latest":  latestVersion,
        }).Info("GitHub API 版本信息")

        // 比较版本
        hasUpdate := s.compareVersions(latestVersion, currentVersion)

        // 找到对应平台的资源
        assetName, downloadURL := s.findPlatformAsset(latestRelease.Assets)

        return &models.UpdateInfo{
            HasUpdate:      hasUpdate,
            LatestVersion:  latestVersion,
            CurrentVersion: currentVersion,
            ReleaseNotes:   latestRelease.Body,
            PublishedAt:    s.parseTime(latestRelease.PublishedAt),
            DownloadURL:    downloadURL,
            AssetName:      assetName,
            Size:           s.getAssetSize(latestRelease.Assets, assetName),
            IsPrerelease:   latestRelease.Prerelease,
            PrereleaseType: s.extractPrereleaseType(latestRelease.TagName),
        }, nil
    }

    // updateCache 更新缓存
    func (s *UpdateService) updateCache(info *models.UpdateInfo) {
        s.mu.Lock()
        s.cachedResult = info
        s.lastCheck = time.Now()
        s.mu.Unlock()
    }
    ```

    主要变更：
    1. 新增 checkViaAPI 方法，封装原有 API 逻辑
    2. CheckForUpdates 改为先尝试 API，失败后降级到 Atom feed
    3. 新增 updateCache 辅助方法，统一缓存更新逻辑
    4. 增强日志输出，明确记录使用的数据源
  </action>
  <verify>go build ./... && go test -run TestCheckForUpdates ./pkg/service/...</verify>
  <done>CheckForUpdates 实现混合降级策略，日志记录数据源</done>
</task>

</tasks>

<verification>
1. 编译验证：go build ./... 成功
2. 单元测试：运行现有测试用例确保兼容性
3. 集成测试：手动测试版本检测功能
   - 模拟 API 失败场景，验证降级到 Atom feed
   - 验证版本比较逻辑正确处理预发布版本
4. 日志验证：检查日志输出，确认数据源记录正确
</verification>

<success_criteria>
1. 代码成功编译，无语法错误
2. 混合降级策略实现：API 优先，Atom feed 备用
3. 版本提取逻辑正确处理各种 feed title 格式
4. 日志清晰记录使用的数据源（API 或 Atom feed）
5. 预发布版本正确识别（alpha/beta/rc）
</success_criteria>

<output>
After completion, create `.planning/phases/07-auto-update-detection-fix/07-01-SUMMARY.md`
</output>
